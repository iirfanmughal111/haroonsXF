var CMTV_Math = window.CMTV_Math || {};
!(function (f, g, h) {
  CMTV_Math.InsertMathForm = XF.Element.newHandler({
    $type: null,
    $latexInput: null,
    $loading: null,
    $previewContainer: null,
    $preview: null,
    $previewError: null,
    $previewEmpty: null,
    state: "empty",
    resetMode: !1,
    _typeTimeout: null,
    _fadeOutTimeout: null,
    typeVal: function () {
      return this.$target.find('[name="math_type"]:checked').val();
    },
    init: function () {
      this.$type = this.$target.find('[name="math_type"]');
      this.$latexInput = this.$target.find('[name="latex_input"]');
      this.$loading = this.$target.find(".preview-loading");
      this.$previewContainer = this.$target.find(".preview-container");
      this.$preview = this.$target.find(".preview");
      this.$previewError = this.$target.find(".error");
      this.$previewEmpty = this.$target.find(".empty");
      this.$type.on("change", XF.proxy(this, "onTypeChange"));
      this.$latexInput.on("input", XF.proxy(this, "onLatexInput"));
      this.$target.on("form:reset", XF.proxy(this, "reset"));
      this.setState("empty");
    },
    onTypeChange: function () {
      this.resetMode || this.updatePreview();
    },
    onLatexInput: function () {
      clearTimeout(this._typeTimeout);
      this.resetMode ||
        (this._typeTimeout = setTimeout(XF.proxy(this, "updatePreview"), 450));
    },
    updatePreview: function () {
      this.fadeOut();
      clearTimeout(this._fadeOutTimeout);
      this._typeTimeout = setTimeout(XF.proxy(this, "changePreview"), 200);
    },
    changePreview: function () {
      var a = this,
        b = this.$latexInput.val().trim();
      b.length
        ? ((b = this.wrapMath(b)),
          this.$preview.html(b),
          this.setState("preview"),
          renderMathInElement(
            this.$preview.get(0),
            Object.assign(CMTV_MATH_RENDER_OPTIONS, {
              errorCallback: function () {
                return a.setState("error");
              },
            })
          ))
        : this.setState("empty");
      this.fadeIn();
    },
    wrapMath: function (a) {
      var b = this.getMathDelimiters("inline" !== this.typeVal());
      return b.left + a + b.right;
    },
    getMathDelimiters: function (a) {
      a = void 0 === a ? !0 : a;
      var b = "\\[",
        c = "\\]";
      !1 === a && ((b = "\\("), (c = "\\)"));
      for (var d = 0; d < CMTV_MATH_RENDER_OPTIONS.delimiters.length; d++) {
        var e = CMTV_MATH_RENDER_OPTIONS.delimiters[d];
        if (e.display === a) {
          b = e.left;
          c = e.right;
          break;
        }
      }
      return { left: b, right: c };
    },
    fadeIn: function () {
      this.$loading.removeClass("showing");
      this.$previewContainer.addClass("showing");
    },
    fadeOut: function () {
      this.$loading.addClass("showing");
      this.$previewContainer.removeClass("showing");
    },
    setState: function (a) {
      this.$preview.hide();
      this.$previewError.hide();
      this.$previewEmpty.hide();
      this.stateVar(a).show();
      this.state = a;
    },
    stateVar: function (a) {
      switch (a) {
        case "empty":
          return this.$previewEmpty;
        case "error":
          return this.$previewError;
        case "preview":
          return this.$preview;
      }
    },
    reset: function () {
      this.resetMode = !0;
      this.$target.find('[name="math_type"][value="block"]').trigger("click");
      this.$latexInput.val("");
      this.updatePreview();
      this.resetMode = !1;
    },
  });
  XF.Element.register("insert-math-form", "CMTV_Math.InsertMathForm");
})(jQuery, window, document);
